









===================================================================================
readdir => 
  the readdir operation allows clients to read the direct contents/children of a 
  directory relative to the service path.

  USAGE ==>
  method => get
  url => coreapi/fs/readdir/<oid>?path=<relative_path>
  headers =>  {
    notstatic: true,
    version: 1,
  },

  @return => if the request was acknowledged, you should get a response 200
    with request body: with signal `ACK/HASPAYLOAD` where the payload is an array containing the
    dir direct children.
    @payloadFormat => {
        payload: [
         { name: "<name>", type: "DIR", size: 0 }, 
         { name: "<name>", type: "FILE", size: 4551 <in bytes> },
         ...etc
        ]
     }
     NOTE: size would always be 0 on type dir.
     an error is returned if the request isnt method get and the path query isnt
     specified
===================================================================================











statics => 
  the statics operation allows clients to retrieve information about a file or
  directoy relative to the service path.

  USAGE ==>
  method => get
  url => coreapi/fs/statics/<oid>?path=<relative_path>
  headers =>  {
    notstatic: true,
    version: 1,
  },

  @return => if the request was acknowledged, you should get a response 200
    with request body: with signal `ACK/HASPAYLOAD` where the payload is an object containing the
    the information of the file or directory.
    @payloadFormat => {
        payload: {
         path: "absolute/path/to/the/requests/relative-path",
         size: <0 for dir  || size of file in bytes>,
         created: "YYYY-MM-DDTHH:MM:SS.MSSZ",
         lmodified: "YYYY-MM-DDTHH:MM:SS.MSSZ",
         isDir: <true || false>
        }
     }
     an error is returned if the request isnt method get and the path query isnt
     specified
===================================================================================










readfile => 
  the readfile operation allows clients to read a file relative to the service path.
  the readfile provides two techniques for file reading : 
  1: reads and return the entire contents of the file (default).
  2: reads the contents of the file batch by batch by calculating the total number
       of lines that are visible in the UI window and return only portion or more if
       specified.
       in this technique you would manually make requests to load the next sections
       of the file.
  NOTE: if the contents of the file is less than a megabyte, gce would use the 
    default technique regardless of wether it was enabled or not.

  USAGE ==>
  method => get
  url => coreapi/fs/readfile/<oid>?path=<relative_path>&useDefault=<bool>
  headers =>  {
    notstatic: true,
    version: 1,
  },

  NOTE: `useDefault=false` tells gce to use the 2nd technique instead, in that case,
   you have to specify the following to the url query:
    `window=<number>&lineHeight=<number>&page=<number>&startLine=<number>` 
    window : the windows height in px <default is 800>,
    lineHeight: your gcce text lineHeight in px <default is 17>,
    page: the page size. eg if you set the value to 2, then number of 
      lines of text that are visible on the window * 2 is whats returned (pagination).
      NOTE specifying 0 would cause the operation to return nothing as 0 means page
      0 while the pages index starts from 1 in gce.  <default is 1>.
      if you specify more pages than there is, gce would return everything.
    startLine: the line at which the rendering should start from. if the startLine 
      exceeds the number of lines then nothing is returned. you can use this to
      indicate you have read the entire file completely.
      <defult is 0> which starts from the first line of the file.

 An example of the request payload if default technique is not used is:
   coreapi/fs/readfile/<oid>?path=relative/path/to/file&useDefault=false&window=700&lineHeight=26&page=2&startLine=0
   NOTE => always use same value for page throughout
   Next batch request can then goes like this :
      coreapi/fs/readfile/<oid>?path=relative/path/to/file&useDefault=false&window=700&lineHeight=26&page=2&startLine=<request 1 number of lines + 1>
      

  @return => if the request was acknowledged, you should get a response 200
    with request body: with signal `ACK/HASPAYLOAD` where the payload is an object containing the
    following:
    @payloadFormat => {
       PAYLOAD: {
        size: <size in bytes>,
        lmodified: 'YYYY-MM-DDTHH:MM:SS.MSSZ',
        data: <contents of the file>,
        usedDefault:
           <boolean indicating wether the opera used the default technique or not>
       }
     }
     an error is returned if the request isnt method get and path and useDefault query 
     params arent specified
===================================================================================
  









  
writefile => 
  the writefile operation allows clients to write data to the specified file 
  relative to the service path.

  USAGE ==>
  method => post
  url => coreapi/fs/writefile/<oid>?path=<relative_path>
  headers =>  {
    notstatic: true,
    version: 1,
  },
  payload: <string :: content to write>

  NOTE : the file is created if it doesnt exists. in situation where you keep
  getting responses with the ONLINE signal it means the .gcelock.<fsname> was
  created but wasnt removed due to an error. in that case you cannot write
  to that file anymore using a gce service unless you manualy navigate to the
  path and remove the .gcelock.<fsname> file / folder.
  note it migth be hidden on some operating systems due to the starting dot.
  on posix you can run l -a to list entries files including hidden. the gce readdir
  opera also reads and return hidden directories too.

  For More Info About the .gcelock.<fsname> look at the gce.dev.doc to read how
  gce works under the hood.


  @return => if the request was acknowledged, you should get a response 200
    with request body: with signal `ACK/HASPAYLOAD` where the payload is an unsigned 
    integer containing the number of bytes written to the file.
    
  an error is returned if the request isnt method post and the path query isnt
  specified
===================================================================================











  makedir => 
    the makedir operation allows clients to create a new directory recursively relative to the
    service path. the directory creation is ignored if it already exists, but you
    would typically get the same response type still.

    USAGE ==>
      method => put
      url => coreapi/fs/makedir/<oid>?path=<relative_path>
      headers =>  {
         notstatic: true,
         version: 1,
      },

    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================









  makefile => 
    the makefile operation allows clients to create a new file relative to the
    service path (not recursively).
    USAGE ==>
      method => put
      url => coreapi/fs/makefile/<oid>?path=<relative_path>
      headers =>  {
         notstatic: true,
         version: 1,
      },
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     

  







  rename => 
    the rename operation allows clients to rename an existing file or directory
    relative to the service path.
    USAGE ==>
      method => put
      url => coreapi/fs/rename/<oid>?path=<relative_path>&new_base=<new_basename>
      headers =>  {
         notstatic: true,
         version: 1,
      },

    Note that the rename opera does not rename the path, but only its lastpath or
    basename. examples :
         app.c - app.cpp  = app.cpp
         src/bin/object.so -  object.dll = src/bin/object.dll
         src/bin/object.so - src/bin/object.dll =  ENOENTRY
    when you rename the root of you directory, you would typically not be able
    to make any other changes to the service anymore as gce stores the absolute path
    in memory when the service is created, and would stick to that until the service
    dies.
    in this case, you would have to manually re-rename the fs to match the name
    when creating the service or restart the service. you migth want to use a shell or file explorer
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     
  







  adminremove => 
    the adminremove operation allows clients to dangerously remove any file or 
    directory relative to the service path.
    THIS OPERATION PERMERNATELY DELTES THE FILE OR DIR SO BE VERY CAREFUL USING THIS.
    GCE RECOMMENDS GCCE'S TO ALWAYS DISPLAY A CONFIRMATION POPUP BEFORE CALLING THIS
    OPERATION.
    USAGE ==>
      method => delete
      url => coreapi/fs/delete/<oid>?path=<relative_path>
      headers =>  {
         notstatic: true,
         version: 1,
      },
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================










  copydir => 
    the copydir operation allows clients to copy the contents of a directory 
    including the sub directories and files to another relative to the service path.
    NOTE that this operation copies the contents of the dir and not the directory 
    itself.
    if the dest does not exists gce creates it. if the source does not exists then 
    an error is thrown, same goes if the source path points to a file.
    the operation copies nothing if the source has noting in its dir.
    USAGE ==>
      method => put
      url => coreapi/fs/copydir/<oid>?source=<relative_path>&dest=<relative_path>
      headers =>  {
         notstatic: true,
         version: 1,
      },
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================










  copyfile => 
    the copyfile operation allows clients to copy the contents of a file to another,
    relative to the service path.
    if the dest does not exists gce creates it. if source is a dir, does'nt exsits
    or dest path has a parent dir or sub dir that does not exists, an error is thrown. 
    USAGE ==>
      method => put
      url => coreapi/fs/copyfile/<oid>?source=<relative_path>&dest=<relative_path>
      headers =>  {
         notstatic: true,
         version: 1,
      },
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     









  movedir => 
    the movedir operation allows clients to move the contents of a directory to 
    another, relative to the service path.
    if source or dest is a file or source does not exists, an error is thrown. 
    if dest does not exists, dest is created.
    USAGE ==>
      method => put
      url => coreapi/fs/movedir/<oid>?source=<relative_path>&dest=<relative_path>
      headers =>  {
         notstatic: true,
         version: 1,
      },
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================










  movefile => 
    the movefile operation allows clients to move a file to a directory relative to 
    the service path.
    the destination path must point to a directory, and source path must point to a 
    file.
    if destination already has source, then the destination data is overwritten.
    if source or destination does'nt exists, then an error is thrown.
    USAGE ==>
      method => put
      url => coreapi/fs/movefile/<oid>?source=<relative_path>&dest=<relative_path>
      headers =>  {
         notstatic: true,
         version: 1,
      },
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================










  remove => 
    the remove operation allows clients to remove a file or directory relative to 
    the service path temporarily.
    this option works exactly like the `move to trash native operation` and you
    can think of it as the same.
    GCE RECOMMENDS THE USAGE OF THIS OPERATION INSTEAD OF THE ADMINREMOVE AS FS
    REMOVED USING THIS OPERATION CAN BE RETRIEVED AS LONG AS THE SERVICE IS STILL
    RUNNING.
    NOTE: THE TRASH FILE IS EMPTIED THE MOMENT THE SERVICE IS KILLED YOU MIGTH WANT
    TO MANUALLY MOVE THE FILE TO TRASH USING A FILE EXPLORER IF YOURE NOT too
    SURE.
    Note: gce uses a temporary file called .TRASHFILE to control the operation and
    retrieval so it is generaly forbiden to remove a file called .TRASHFILE or
    remove a directory containing any file named .TRASHFILE
    USAGE ==>
      method => delete
      url => coreapi/fs/remove/<oid>?path=<relative_path>&isfile=<bool>
      headers =>  {
         notstatic: true,
         version: 1,
      },
    @return => if the request was acknowledged, you should get a response 200
    with request body: with signal `ACK/HASPAYLOAD` where the payload is a pointer or reference
    <id> to the path in which the removed fs is stored.
====================================================================================










  restore => 
    the restore operation allows clients to restore a file or directory removed
    using the REMOVE operation.
    Note: if the file or directory was already re-created <bearing the same name
    in the same path>
    and contains items, the restore operation would rewrite the contents.
    USAGE ==>
      method => put
      url => coreapi/fs/restore/<oid>?pointer=<pointer>
      headers =>  {
         notstatic: true,
         version: 1,
      },
    where the pointer query is the pointer or reference <id> to the removed fs
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`
====================================================================================
     

























































  
  SERVICEINFO => 
    treturns info about the service.
    @request => {
        "TYPE": "FS",
        "OPERA": "SERVICEINFO",
        "OID": "<REQEUSTID>",
        "PAYLOAD": ""
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK/HASPAYLOAD` where paload is an object containinig the 
      service info.
====================================================================================
     