
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
This file contains documentation for working with crud operations on the pc's 
file system using gce's service api.

GCE RECOMMENDS DEVELOPERS TO PLAY WITH THE OPERATIONS PROVIDED IN THIS FILE
TO UNDERSTAND HOW THEY WORK BEFORE MAKING YOUR OWN GCCE.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

-- SAPI TYPE = FS
-- OPERATION TYPES =

  READDIR => 
    the readdir operation allows clients to read the direct contents/children of a 
    directory relative to the service path.
    @request => {
        "TYPE": "FS",
        "OPERA": "READDIR",
        "OID": "<REQEUSTID>",
        "PAYLOAD": "relative/path/to/dir"
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK/HASPAYLOAD` where the payload is an array containing the
      dir direct children.
    @payloadFormat => {
        PAYLOAD: [
         { name: "<name>", type: "DIR", size: 0 }, 
         { name: "<name>", type: "FILE", size: 4551 <in bytes> },
         ...etc
        ]
     }
     NOTE: size would always be 0 on type dir.
===================================================================================
     
  
  STATICS => 
    the statics operation allows clients to retrieve information about a file or
    directoy relative to the service path.
    @request => {
        "TYPE": "FS",
        "OPERA": "STATICS",
        "OID": "<REQEUSTID>",
        "PAYLOAD": "relative/path/to/path"
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK/HASPAYLOAD` where the payload is an object containing the
      the information of the file or directory.
    @payloadFormat => {
        PAYLOAD: {
         path: "absolute/path/to/the/requests/relative-path",
         size: <0 for dir  || size of file in bytes>,
         created: "YYYY-MM-DDTHH:MM:SS.MSSZ",
         lmodified: "YYYY-MM-DDTHH:MM:SS.MSSZ",
         isDir: <true || false>
        }
     }
====================================================================================


  READFILE => 
    the readfile operation allows clients to read a file relative to the service path.
    the readfile provides two techniques for file reading : 
    1: reads and return the entire contents of the file (default).
    2: reads the contents of the file batch by batch by calculating the total number
       of lines that are visible in the UI window and return only portion or more if
       specified.
       in this technique you would manually make requests to load the next sections
       of the file.
    NOTE: if the contents of the file is less than a megabyte, gce would use the 
    default technique regardless of wether it was enabled or not.
    @request => {
        "TYPE": "FS",
        "OPERA": "READFILE",
        "OID": "<REQEUSTID>",
        "PAYLOAD":  {
          "path" : "relative/path/to/file",
          "useDefault" : <true || false>,
        }
      }
     NOTE: `useDefault : false` tells gce to use the 2nd technique instead. 
     you must specify the following fields in other for the second technique to work:
     window : the windows height in px <default is 800>,
     lineHeight: your gcce text lineHeight in px <default is 17>,
     page: the page size. eg if you set the value to 2, then number of 
        lines of text that are visible on the window * 2 is whats returned (pagination).
        NOTE specifying 0 would cause the operation to return nothing as 0 means page
        0 while the pages index starts from 1 in gce.  <default is 1>.
        if you specify more pages than there is, gce would return everything.
     startLine: the line at which the rendering should start from. if the startLine 
        exceeds the number of lines then nothing is returned. you can use this to
        indicate you have read the entire file completely.
        <defult is 0> which starts from the first line of the file.
     An example of the request payload if default technique is not used is:
        "PAYLOAD":  {
          "path" : "relative/path/to/file",
          "useDefault" : false,
          "window" : 700,
          "lineHeight": 26,
          "page": 2, //always use same value throughout
          "startLine": 0,
        }  
      Next batch request can then goes like this :
        "PAYLOAD":  {
          "path" : "relative/path/to/file",
          "useDefault" : false,
          "window" : 700,
          "lineHeight": 26,
          "page": 2, //always use same value throughout
          "startLine": <request 1 number of lines + 1>,
        }  

    @return => if the request was acknowledged, you should get a response
      with signal `ACK/HASPAYLOAD` where the payload is an object containing the
      following:
    @payloadFormat => {
       PAYLOAD: {
        size: <size in bytes>,
        lmodified: 'YYYY-MM-DDTHH:MM:SS.MSSZ',
        data: <contents of the file>,
        usedDefault:
           <boolean indicating wether the opera used the default technique or not>
       }
     }
=====================================================================================


  WRITEFILE => 
    the writefile operation allows clients to write data to the specified file 
    relative to the service path.
    @request => {
        "TYPE": "FS",
        "OPERA": "WRITEFILE",
        "OID": "<REQEUSTID>",
        "PAYLOAD": {
           "path": "relative/path/to/file",
           "content": "<THE DATA TO WRITE>"
        }
      }
    NOTE : the file is created if it doesnt exists. in situation where you keep
    getting responses with the ONLINE signal it means the .gcelock.<fsname> was
    created but wasnt removed due to an error. in that case you cannot write
    to that file anymore using a gce service unless you manualy navigate to the
    path and remove the .gcelock.<fsname> file / folder.
    note it migth be hidden on some operating systems due to the starting dot.
    on posix you can run l -a to list entries files including hidden. the gce readdir
    opera also reads and return hidden directories too.

    For More Info About the .gcelock.<fsname> look at the gce.dev.doc to read how
    gce works under the hood.

    @return => if the request was acknowledged, you should get a response
      with signal `ACK/HASPAYLOAD` where the payload is an unsigned integer 
      containing the number of bytes written to the file.
===================================================================================
     
  
  MAKEDIR => 
    the makedir operation allows clients to create a new directory relative to the
    service path. the directory creation is ignored if it already exists, but you
    would typically get the same response type still.
    @request => {
        "TYPE": "FS",
        "OPERA": "MAKEDIR",
        "OID": "<REQEUSTID>",
        "PAYLOAD": "relative/path/to/newdir"
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     
  
  MAKEFILE => 
    the makefile operation allows clients to create a new file relative to the
    service path.
    @request => {
        "TYPE": "FS",
        "OPERA": "MAKEFILE",
        "OID": "<REQEUSTID>",
        "PAYLOAD": "relative/path/to/newfile"
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     
  
  RENAME => 
    the rename operation allows clients to rename an existing file or directory
    relative to the service path.
    @request => {
        "TYPE": "FS",
        "OPERA": "RENAME",
        "OID": "<REQEUSTID>",
        "PAYLOAD":  {
          "path" : "relative/path/to/target",
          "new_basename" : "<name>"
        }
      }
    Note that the rename opera does not rename the path, but only its lastpath or
    basename. examples :
         app.c - app.cpp  = app.cpp
         src/bin/object.so -  object.dll = src/bin/object.dll
         src/bin/object.so - src/bin/object.dll =  ENOENTRY
    when you rename the root of you directory, you would typically not be able
    to make any other changes to the service anymore as gce stores the absolute path
    in memory when the service is created, and would stick to that until the service
    dies.
    in this case, you would have to manually re-rename the fs to match the name
    when creating the service. you migth want to use a shell or file explorer
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     
  
  ADMINREMOVE => 
    the adminremove operation allows clients to dangerously remove any file or 
    directory relative to the service path.
    THIS OPERATION PERMERNATELY DELTES THE FILE OR DIR SO BE VERY CAREFUL USING THIS.
    GCE RECOMMENDS GCCE'S TO ALWAYS DISPLAY A CONFIRMATION POPUP BEFORE CALLING THIS
    OPERATION.
    @request => {
        "TYPE": "FS",
        "OPERA": "ADMINREMOVE",
        "OID": "<REQEUSTID>",
        "PAYLOAD": "relative/path/to/file"
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     
  
  COPYDIR => 
    the copydir operation allows clients to copy the contents of a directory 
    including the sub directories and files to another relative to the service path.
    NOTE that this operation copies the contents of the dir and not the directory 
    itself.
    if the dest does not exists gce creates it. if the source does not exists then 
    an error is thrown, same goes if the source path points to a file.
    the operation copies nothing if the source has noting in its dir.
    @request => {
        "TYPE": "FS",
        "OPERA": "COPYDIR",
        "OID": "<REQEUSTID>",
        "PAYLOAD": {
          "source" : "relative/path/to/dir",
          "dest" : "relative/path/to/dir"
        }
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     
  
  COPYFILE => 
    the copyfile operation allows clients to copy the contents of a file to another,
    relative to the service path.
    if the dest does not exists gce creates it. if source is a dir, does'nt exsits
    or dest path has a parent dir or sub dir that does not exists, an error is thrown. 
    @request => {
        "TYPE": "FS",
        "OPERA": "COPYFILE",
        "OID": "<REQEUSTID>",
        "PAYLOAD": {
          "source" : "relative/path/to/file",
          "dest" : "relative/path/to/dir"
        }
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     
  
  MOVEDIR => 
    the movedir operation allows clients to move the contents of a directory to 
    another, relative to the service path.
    if source or dest is a file or source does not exists, an error is thrown. 
    if dest does not exists, dest is created.
    @request => {
        "TYPE": "FS",
        "OPERA": "MOVEDIR",
        "OID": "<REQEUSTID>",
        "PAYLOAD": {
          "source" : "relative/path/to/dir",
          "dest" : "relative/path/to/dir"
        }
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     
  
  MOVEFILE => 
    the movefile operation allows clients to move a file to a directory relative to 
    the service path.
    the destination path must point to a directory, and source path must point to a 
    file.
    if destination already has source, then the destination data is overwritten.
    if source or destination does'nt exists, then an error is thrown.
    @request => {
        "TYPE": "FS",
        "OPERA": "MOVEFILE",
        "OID": "<REQEUSTID>",
        "PAYLOAD": {
          "source" : "relative/path/to/file",
          "dest" : "relative/path/to/dir"
        }
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`.
====================================================================================
     
  
  REMOVE => 
    the remove operation allows clients to remove a file or directory relative to 
    the service path temporarily.
    this option works exactly like the `move to trash native operation` and you
    can think of it as the same.
    GCE RECOMMENDS THE USAGE OF THIS OPERATION INSTEAD OF THE ADMINREMOVE AS FS
    REMOVED USING THIS OPERATION CAN BE RETRIEVED AS LONG AS THE SERVICE IS STILL
    RUNNING.
    Note: gce uses a temporary file called .TRASHFILE to control the operation and
    retrieval so it is generaly forbiden to remove a file called .TRASHFILE or
    remove a directory containing any file named .TRASHFILE
    @request => {
        "TYPE": "FS",
        "OPERA": "REMOVE",
        "OID": "<REQEUSTID>",
        "PAYLOAD": {
          "isFile" : <true || false>,
          "path" : "relative/path/to/dir or file"
        }
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK/HASPAYLOAD` where the payload is a pointer or reference
      <id> to the path in which the removed fs is stored.
====================================================================================
     
  
  RESTORE => 
    the restore operation allows clients to restore a file or directory removed
    using the REMOVE operation.
    Note: if the file or directory was already re-created <bearing the same name
    in the same path>
    and contains items, the restore operation would rewrite the contents.
    @request => {
        "TYPE": "FS",
        "OPERA": "  RESTORE",
        "OID": "<REQEUSTID>",
        "PAYLOAD": "pointer or reference <id> to the removed fs"
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK`
====================================================================================
     
  
  SERVICEINFO => 
    treturns info about the service.
    @request => {
        "TYPE": "FS",
        "OPERA": "SERVICEINFO",
        "OID": "<REQEUSTID>",
        "PAYLOAD": ""
      }
    @return => if the request was acknowledged, you should get a response
      with signal `ACK/HASPAYLOAD` where paload is an object containinig the 
      service info.
====================================================================================
     